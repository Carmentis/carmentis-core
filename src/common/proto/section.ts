// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v3.20.3
// source: section.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "carmentis";

export enum SectionType {
  /** ACCOUNT_SIG_ALGORITHM - Account */
  ACCOUNT_SIG_ALGORITHM = 0,
  ACCOUNT_PUBLIC_KEY = 1,
  ACCOUNT_TOKEN_ISSUANCE = 2,
  ACCOUNT_CREATION = 3,
  ACCOUNT_TRANSFER = 4,
  ACCOUNT_SIGNATURE = 5,
  /** ORG_SIG_ALGORITHM - Organization */
  ORG_SIG_ALGORITHM = 100,
  ORG_PUBLIC_KEY = 101,
  ORG_DESCRIPTION = 102,
  ORG_SERVER = 103,
  ORG_SIGNATURE = 104,
  /** APP_SIG_ALGORITHM - Application */
  APP_SIG_ALGORITHM = 200,
  APP_DECLARATION = 201,
  APP_DESCRIPTION = 202,
  APP_SIGNATURE = 203,
  /** APP_LEDGER_SIG_ALGORITHM - Application Ledger */
  APP_LEDGER_SIG_ALGORITHM = 300,
  APP_LEDGER_DECLARATION = 301,
  APP_LEDGER_ACTOR_CREATION = 302,
  APP_LEDGER_CHANNEL_CREATION = 303,
  APP_LEDGER_SHARED_SECRET = 304,
  APP_LEDGER_CHANNEL_INVITATION = 305,
  APP_LEDGER_ACTOR_SUBSCRIPTION = 306,
  APP_LEDGER_PUBLIC_CHANNEL_DATA = 307,
  APP_LEDGER_PRIVATE_CHANNEL_DATA = 308,
  APP_LEDGER_AUTHOR = 309,
  APP_LEDGER_ENDORSER = 310,
  APP_LEDGER_ENDORSER_SIGNATURE = 311,
  APP_LEDGER_AUTHOR_SIGNATURE = 312,
  UNRECOGNIZED = -1,
}

export function sectionTypeFromJSON(object: any): SectionType {
  switch (object) {
    case 0:
    case "ACCOUNT_SIG_ALGORITHM":
      return SectionType.ACCOUNT_SIG_ALGORITHM;
    case 1:
    case "ACCOUNT_PUBLIC_KEY":
      return SectionType.ACCOUNT_PUBLIC_KEY;
    case 2:
    case "ACCOUNT_TOKEN_ISSUANCE":
      return SectionType.ACCOUNT_TOKEN_ISSUANCE;
    case 3:
    case "ACCOUNT_CREATION":
      return SectionType.ACCOUNT_CREATION;
    case 4:
    case "ACCOUNT_TRANSFER":
      return SectionType.ACCOUNT_TRANSFER;
    case 5:
    case "ACCOUNT_SIGNATURE":
      return SectionType.ACCOUNT_SIGNATURE;
    case 100:
    case "ORG_SIG_ALGORITHM":
      return SectionType.ORG_SIG_ALGORITHM;
    case 101:
    case "ORG_PUBLIC_KEY":
      return SectionType.ORG_PUBLIC_KEY;
    case 102:
    case "ORG_DESCRIPTION":
      return SectionType.ORG_DESCRIPTION;
    case 103:
    case "ORG_SERVER":
      return SectionType.ORG_SERVER;
    case 104:
    case "ORG_SIGNATURE":
      return SectionType.ORG_SIGNATURE;
    case 200:
    case "APP_SIG_ALGORITHM":
      return SectionType.APP_SIG_ALGORITHM;
    case 201:
    case "APP_DECLARATION":
      return SectionType.APP_DECLARATION;
    case 202:
    case "APP_DESCRIPTION":
      return SectionType.APP_DESCRIPTION;
    case 203:
    case "APP_SIGNATURE":
      return SectionType.APP_SIGNATURE;
    case 300:
    case "APP_LEDGER_SIG_ALGORITHM":
      return SectionType.APP_LEDGER_SIG_ALGORITHM;
    case 301:
    case "APP_LEDGER_DECLARATION":
      return SectionType.APP_LEDGER_DECLARATION;
    case 302:
    case "APP_LEDGER_ACTOR_CREATION":
      return SectionType.APP_LEDGER_ACTOR_CREATION;
    case 303:
    case "APP_LEDGER_CHANNEL_CREATION":
      return SectionType.APP_LEDGER_CHANNEL_CREATION;
    case 304:
    case "APP_LEDGER_SHARED_SECRET":
      return SectionType.APP_LEDGER_SHARED_SECRET;
    case 305:
    case "APP_LEDGER_CHANNEL_INVITATION":
      return SectionType.APP_LEDGER_CHANNEL_INVITATION;
    case 306:
    case "APP_LEDGER_ACTOR_SUBSCRIPTION":
      return SectionType.APP_LEDGER_ACTOR_SUBSCRIPTION;
    case 307:
    case "APP_LEDGER_PUBLIC_CHANNEL_DATA":
      return SectionType.APP_LEDGER_PUBLIC_CHANNEL_DATA;
    case 308:
    case "APP_LEDGER_PRIVATE_CHANNEL_DATA":
      return SectionType.APP_LEDGER_PRIVATE_CHANNEL_DATA;
    case 309:
    case "APP_LEDGER_AUTHOR":
      return SectionType.APP_LEDGER_AUTHOR;
    case 310:
    case "APP_LEDGER_ENDORSER":
      return SectionType.APP_LEDGER_ENDORSER;
    case 311:
    case "APP_LEDGER_ENDORSER_SIGNATURE":
      return SectionType.APP_LEDGER_ENDORSER_SIGNATURE;
    case 312:
    case "APP_LEDGER_AUTHOR_SIGNATURE":
      return SectionType.APP_LEDGER_AUTHOR_SIGNATURE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SectionType.UNRECOGNIZED;
  }
}

export function sectionTypeToJSON(object: SectionType): string {
  switch (object) {
    case SectionType.ACCOUNT_SIG_ALGORITHM:
      return "ACCOUNT_SIG_ALGORITHM";
    case SectionType.ACCOUNT_PUBLIC_KEY:
      return "ACCOUNT_PUBLIC_KEY";
    case SectionType.ACCOUNT_TOKEN_ISSUANCE:
      return "ACCOUNT_TOKEN_ISSUANCE";
    case SectionType.ACCOUNT_CREATION:
      return "ACCOUNT_CREATION";
    case SectionType.ACCOUNT_TRANSFER:
      return "ACCOUNT_TRANSFER";
    case SectionType.ACCOUNT_SIGNATURE:
      return "ACCOUNT_SIGNATURE";
    case SectionType.ORG_SIG_ALGORITHM:
      return "ORG_SIG_ALGORITHM";
    case SectionType.ORG_PUBLIC_KEY:
      return "ORG_PUBLIC_KEY";
    case SectionType.ORG_DESCRIPTION:
      return "ORG_DESCRIPTION";
    case SectionType.ORG_SERVER:
      return "ORG_SERVER";
    case SectionType.ORG_SIGNATURE:
      return "ORG_SIGNATURE";
    case SectionType.APP_SIG_ALGORITHM:
      return "APP_SIG_ALGORITHM";
    case SectionType.APP_DECLARATION:
      return "APP_DECLARATION";
    case SectionType.APP_DESCRIPTION:
      return "APP_DESCRIPTION";
    case SectionType.APP_SIGNATURE:
      return "APP_SIGNATURE";
    case SectionType.APP_LEDGER_SIG_ALGORITHM:
      return "APP_LEDGER_SIG_ALGORITHM";
    case SectionType.APP_LEDGER_DECLARATION:
      return "APP_LEDGER_DECLARATION";
    case SectionType.APP_LEDGER_ACTOR_CREATION:
      return "APP_LEDGER_ACTOR_CREATION";
    case SectionType.APP_LEDGER_CHANNEL_CREATION:
      return "APP_LEDGER_CHANNEL_CREATION";
    case SectionType.APP_LEDGER_SHARED_SECRET:
      return "APP_LEDGER_SHARED_SECRET";
    case SectionType.APP_LEDGER_CHANNEL_INVITATION:
      return "APP_LEDGER_CHANNEL_INVITATION";
    case SectionType.APP_LEDGER_ACTOR_SUBSCRIPTION:
      return "APP_LEDGER_ACTOR_SUBSCRIPTION";
    case SectionType.APP_LEDGER_PUBLIC_CHANNEL_DATA:
      return "APP_LEDGER_PUBLIC_CHANNEL_DATA";
    case SectionType.APP_LEDGER_PRIVATE_CHANNEL_DATA:
      return "APP_LEDGER_PRIVATE_CHANNEL_DATA";
    case SectionType.APP_LEDGER_AUTHOR:
      return "APP_LEDGER_AUTHOR";
    case SectionType.APP_LEDGER_ENDORSER:
      return "APP_LEDGER_ENDORSER";
    case SectionType.APP_LEDGER_ENDORSER_SIGNATURE:
      return "APP_LEDGER_ENDORSER_SIGNATURE";
    case SectionType.APP_LEDGER_AUTHOR_SIGNATURE:
      return "APP_LEDGER_AUTHOR_SIGNATURE";
    case SectionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MicroBlockType {
  ACCOUNT_MICROBLOCK = 0,
  ORGANISATION_MICROBLOCK = 1,
  APPLICATION_MICROBLOCK = 2,
  APP_LEDGER_MICROBLOCK = 3,
  NODE_MICROBLOCK = 4,
  UNRECOGNIZED = -1,
}

export function microBlockTypeFromJSON(object: any): MicroBlockType {
  switch (object) {
    case 0:
    case "ACCOUNT_MICROBLOCK":
      return MicroBlockType.ACCOUNT_MICROBLOCK;
    case 1:
    case "ORGANISATION_MICROBLOCK":
      return MicroBlockType.ORGANISATION_MICROBLOCK;
    case 2:
    case "APPLICATION_MICROBLOCK":
      return MicroBlockType.APPLICATION_MICROBLOCK;
    case 3:
    case "APP_LEDGER_MICROBLOCK":
      return MicroBlockType.APP_LEDGER_MICROBLOCK;
    case 4:
    case "NODE_MICROBLOCK":
      return MicroBlockType.NODE_MICROBLOCK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MicroBlockType.UNRECOGNIZED;
  }
}

export function microBlockTypeToJSON(object: MicroBlockType): string {
  switch (object) {
    case MicroBlockType.ACCOUNT_MICROBLOCK:
      return "ACCOUNT_MICROBLOCK";
    case MicroBlockType.ORGANISATION_MICROBLOCK:
      return "ORGANISATION_MICROBLOCK";
    case MicroBlockType.APPLICATION_MICROBLOCK:
      return "APPLICATION_MICROBLOCK";
    case MicroBlockType.APP_LEDGER_MICROBLOCK:
      return "APP_LEDGER_MICROBLOCK";
    case MicroBlockType.NODE_MICROBLOCK:
      return "NODE_MICROBLOCK";
    case MicroBlockType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum VirtualBlockchainType {
  ACCOUNT_VIRTUAL_BLOCKCHAIN = 0,
  NODE_VIRTUAL_BLOCKCHAIN = 1,
  APPLICATION_VIRTUAL_BLOCKCHAIN = 2,
  ORGANISATION_VIRTUAL_BLOCKCHAIN = 3,
  APP_LEDGER_VIRTUAL_BLOCKCHAIN = 4,
  UNRECOGNIZED = -1,
}

export function virtualBlockchainTypeFromJSON(object: any): VirtualBlockchainType {
  switch (object) {
    case 0:
    case "ACCOUNT_VIRTUAL_BLOCKCHAIN":
      return VirtualBlockchainType.ACCOUNT_VIRTUAL_BLOCKCHAIN;
    case 1:
    case "NODE_VIRTUAL_BLOCKCHAIN":
      return VirtualBlockchainType.NODE_VIRTUAL_BLOCKCHAIN;
    case 2:
    case "APPLICATION_VIRTUAL_BLOCKCHAIN":
      return VirtualBlockchainType.APPLICATION_VIRTUAL_BLOCKCHAIN;
    case 3:
    case "ORGANISATION_VIRTUAL_BLOCKCHAIN":
      return VirtualBlockchainType.ORGANISATION_VIRTUAL_BLOCKCHAIN;
    case 4:
    case "APP_LEDGER_VIRTUAL_BLOCKCHAIN":
      return VirtualBlockchainType.APP_LEDGER_VIRTUAL_BLOCKCHAIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VirtualBlockchainType.UNRECOGNIZED;
  }
}

export function virtualBlockchainTypeToJSON(object: VirtualBlockchainType): string {
  switch (object) {
    case VirtualBlockchainType.ACCOUNT_VIRTUAL_BLOCKCHAIN:
      return "ACCOUNT_VIRTUAL_BLOCKCHAIN";
    case VirtualBlockchainType.NODE_VIRTUAL_BLOCKCHAIN:
      return "NODE_VIRTUAL_BLOCKCHAIN";
    case VirtualBlockchainType.APPLICATION_VIRTUAL_BLOCKCHAIN:
      return "APPLICATION_VIRTUAL_BLOCKCHAIN";
    case VirtualBlockchainType.ORGANISATION_VIRTUAL_BLOCKCHAIN:
      return "ORGANISATION_VIRTUAL_BLOCKCHAIN";
    case VirtualBlockchainType.APP_LEDGER_VIRTUAL_BLOCKCHAIN:
      return "APP_LEDGER_VIRTUAL_BLOCKCHAIN";
    case VirtualBlockchainType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface VirtualBlockchainViewSchema {
  type: VirtualBlockchainType;
  height: number;
  blocks: MicroBlockSchema[];
}

export interface MicroBlockHeaderSchema {
  type: MicroBlockType;
  height: number;
  gasPrice: number;
  magicString: string;
  previousHash: Uint8Array;
  timestamp: number;
  gas: number;
  bodyHash: Uint8Array;
}

export interface MicroBlockSchema {
  header: MicroBlockHeaderSchema | undefined;
  hash: Uint8Array;
  sections: SectionSchema[];
  feesPayerAccount?: Uint8Array | undefined;
}

export interface SectionSchema {
  sectionType: SectionType;
  data: SectionDataSchema | undefined;
}

export interface SectionDataSchema {
  accountSigAlgorithm?: AccountSigAlgorithmSectionSchema | undefined;
  accountPublicKey?: AccountPublicKeySectionSchema | undefined;
  accountTokenIssuance?: AccountTokenIssuanceSectionSchema | undefined;
  accountCreation?: AccountCreationSectionSchema | undefined;
  accountTransfer?: AccountTransferSectionSchema | undefined;
  accountSignature?: AccountSignatureSectionSchema | undefined;
  orgSigAlgorithm?: OrgSigAlgorithmSectionSchema | undefined;
  orgPublicKey?: OrgPublicKeySectionSchema | undefined;
  orgDescription?: OrgDescriptionSectionSchema | undefined;
  orgServer?: OrgServerSectionSchema | undefined;
  orgSignature?: OrgSignatureSectionSchema | undefined;
  appSigAlgorithm?: AppSigAlgorithmSectionSchema | undefined;
  appDeclaration?: AppDeclarationSectionSchema | undefined;
  appDescription?: AppDescriptionSectionSchema | undefined;
  appSignature?: AppSignatureSectionSchema | undefined;
  appLedgerSigAlgorithm?: AppLedgerSigAlgorithmSectionSchema | undefined;
  appLedgerDeclaration?: AppLedgerDeclarationSectionSchema | undefined;
  appLedgerActorCreation?: AppLedgerActorCreationSectionSchema | undefined;
  appLedgerChannelCreation?: AppLedgerChannelCreationSectionSchema | undefined;
  appLedgerSharedSecret?: AppLedgerSharedSecretSectionSchema | undefined;
  appLedgerChannelInvitation?: AppLedgerChannelInvitationSectionSchema | undefined;
  appLedgerActorSubscription?: AppLedgerActorSubscriptionSectionSchema | undefined;
  appLedgerPublicChannelData?: AppLedgerPublicChannelDataSectionSchema | undefined;
  appLedgerPrivateChannelData?: AppLedgerPrivateChannelDataSectionSchema | undefined;
  appLedgerAuthor?: AppLedgerAuthorSectionSchema | undefined;
  appLedgerEndorser?: AppLedgerEndorserSectionSchema | undefined;
  appLedgerEndorserSignature?: AppLedgerEndorserSignatureSectionSchema | undefined;
  appLedgerAuthorSignature?: AppLedgerAuthorSignatureSectionSchema | undefined;
}

export interface AccountSigAlgorithmSectionSchema {
  algorithmId: number;
}

export interface AccountPublicKeySectionSchema {
  publicKey: Uint8Array;
}

export interface AccountTokenIssuanceSectionSchema {
  amount: number;
}

export interface AccountCreationSectionSchema {
  sellerAccount: Uint8Array;
  amount: number;
}

export interface AccountTransferSectionSchema {
  account: Uint8Array;
  amount: number;
  publicReference: string;
  privateReference: string;
}

export interface AccountSignatureSectionSchema {
  signature: Uint8Array;
}

export interface OrgSigAlgorithmSectionSchema {
  algorithmId: number;
}

export interface OrgPublicKeySectionSchema {
  publicKey: Uint8Array;
}

export interface OrgDescriptionSectionSchema {
  name: string;
  city: string;
  /** length = 2 (en TS à vérifier) */
  countryCode: string;
  website: string;
}

export interface OrgServerSectionSchema {
  endpoint: string;
}

export interface OrgSignatureSectionSchema {
  signature: Uint8Array;
}

export interface AppSigAlgorithmSectionSchema {
  algorithmId: number;
}

export interface AppDeclarationSectionSchema {
  organizationId: Uint8Array;
}

export interface AppDescriptionSectionSchema {
  name: string;
  logoUrl: string;
  homepageUrl: string;
  description: string;
}

export interface AppSignatureSectionSchema {
  signature: Uint8Array;
}

export interface AppLedgerSigAlgorithmSectionSchema {
  algorithmId: number;
}

export interface AppLedgerDeclarationSectionSchema {
  applicationId: Uint8Array;
}

export interface AppLedgerActorCreationSectionSchema {
  id: number;
  type: number;
  name: string;
}

export interface AppLedgerChannelCreationSectionSchema {
  id: number;
  isPrivate: boolean;
  creatorId: number;
  name: string;
}

export interface AppLedgerSharedSecretSectionSchema {
  hostId: number;
  guestId: number;
  encapsulation: Uint8Array;
}

export interface AppLedgerChannelInvitationSectionSchema {
  channelId: number;
  hostId: number;
  guestId: number;
  channelKey: Uint8Array;
}

export interface AppLedgerActorSubscriptionSectionSchema {
  actorId: number;
  actorType: number;
  organizationId: Uint8Array;
  kemPublicKey: Uint8Array;
  signaturePublicKey: Uint8Array;
}

export interface AppLedgerPublicChannelDataSectionSchema {
  channelId: number;
  data: Uint8Array;
}

export interface AppLedgerPrivateChannelDataSectionSchema {
  channelId: number;
  merkleRootHash: Uint8Array;
  encryptedData: Uint8Array;
}

export interface AppLedgerAuthorSectionSchema {
  authorId: number;
}

export interface AppLedgerEndorserSectionSchema {
  endorserId: number;
  messageId: number;
}

export interface AppLedgerEndorserSignatureSectionSchema {
  signature: Uint8Array;
}

export interface AppLedgerAuthorSignatureSectionSchema {
  signature: Uint8Array;
}

function createBaseVirtualBlockchainViewSchema(): VirtualBlockchainViewSchema {
  return { type: 0, height: 0, blocks: [] };
}

export const VirtualBlockchainViewSchema: MessageFns<VirtualBlockchainViewSchema> = {
  encode(message: VirtualBlockchainViewSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.height !== 0) {
      writer.uint32(16).uint64(message.height);
    }
    for (const v of message.blocks) {
      MicroBlockSchema.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualBlockchainViewSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualBlockchainViewSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blocks.push(MicroBlockSchema.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualBlockchainViewSchema {
    return {
      type: isSet(object.type) ? virtualBlockchainTypeFromJSON(object.type) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      blocks: globalThis.Array.isArray(object?.blocks)
        ? object.blocks.map((e: any) => MicroBlockSchema.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VirtualBlockchainViewSchema): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = virtualBlockchainTypeToJSON(message.type);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => MicroBlockSchema.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualBlockchainViewSchema>, I>>(base?: I): VirtualBlockchainViewSchema {
    return VirtualBlockchainViewSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtualBlockchainViewSchema>, I>>(object: I): VirtualBlockchainViewSchema {
    const message = createBaseVirtualBlockchainViewSchema();
    message.type = object.type ?? 0;
    message.height = object.height ?? 0;
    message.blocks = object.blocks?.map((e) => MicroBlockSchema.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMicroBlockHeaderSchema(): MicroBlockHeaderSchema {
  return {
    type: 0,
    height: 0,
    gasPrice: 0,
    magicString: "",
    previousHash: new Uint8Array(0),
    timestamp: 0,
    gas: 0,
    bodyHash: new Uint8Array(0),
  };
}

export const MicroBlockHeaderSchema: MessageFns<MicroBlockHeaderSchema> = {
  encode(message: MicroBlockHeaderSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.height !== 0) {
      writer.uint32(16).uint64(message.height);
    }
    if (message.gasPrice !== 0) {
      writer.uint32(37).float(message.gasPrice);
    }
    if (message.magicString !== "") {
      writer.uint32(50).string(message.magicString);
    }
    if (message.previousHash.length !== 0) {
      writer.uint32(58).bytes(message.previousHash);
    }
    if (message.timestamp !== 0) {
      writer.uint32(64).uint64(message.timestamp);
    }
    if (message.gas !== 0) {
      writer.uint32(72).uint64(message.gas);
    }
    if (message.bodyHash.length !== 0) {
      writer.uint32(82).bytes(message.bodyHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MicroBlockHeaderSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMicroBlockHeaderSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.gasPrice = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.magicString = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.previousHash = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.timestamp = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.gas = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.bodyHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MicroBlockHeaderSchema {
    return {
      type: isSet(object.type) ? microBlockTypeFromJSON(object.type) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      gasPrice: isSet(object.gasPrice) ? globalThis.Number(object.gasPrice) : 0,
      magicString: isSet(object.magicString) ? globalThis.String(object.magicString) : "",
      previousHash: isSet(object.previousHash) ? bytesFromBase64(object.previousHash) : new Uint8Array(0),
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      gas: isSet(object.gas) ? globalThis.Number(object.gas) : 0,
      bodyHash: isSet(object.bodyHash) ? bytesFromBase64(object.bodyHash) : new Uint8Array(0),
    };
  },

  toJSON(message: MicroBlockHeaderSchema): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = microBlockTypeToJSON(message.type);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.gasPrice !== 0) {
      obj.gasPrice = message.gasPrice;
    }
    if (message.magicString !== "") {
      obj.magicString = message.magicString;
    }
    if (message.previousHash.length !== 0) {
      obj.previousHash = base64FromBytes(message.previousHash);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.gas !== 0) {
      obj.gas = Math.round(message.gas);
    }
    if (message.bodyHash.length !== 0) {
      obj.bodyHash = base64FromBytes(message.bodyHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MicroBlockHeaderSchema>, I>>(base?: I): MicroBlockHeaderSchema {
    return MicroBlockHeaderSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MicroBlockHeaderSchema>, I>>(object: I): MicroBlockHeaderSchema {
    const message = createBaseMicroBlockHeaderSchema();
    message.type = object.type ?? 0;
    message.height = object.height ?? 0;
    message.gasPrice = object.gasPrice ?? 0;
    message.magicString = object.magicString ?? "";
    message.previousHash = object.previousHash ?? new Uint8Array(0);
    message.timestamp = object.timestamp ?? 0;
    message.gas = object.gas ?? 0;
    message.bodyHash = object.bodyHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMicroBlockSchema(): MicroBlockSchema {
  return { header: undefined, hash: new Uint8Array(0), sections: [], feesPayerAccount: undefined };
}

export const MicroBlockSchema: MessageFns<MicroBlockSchema> = {
  encode(message: MicroBlockSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      MicroBlockHeaderSchema.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    for (const v of message.sections) {
      SectionSchema.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.feesPayerAccount !== undefined) {
      writer.uint32(34).bytes(message.feesPayerAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MicroBlockSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMicroBlockSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = MicroBlockHeaderSchema.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sections.push(SectionSchema.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feesPayerAccount = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MicroBlockSchema {
    return {
      header: isSet(object.header) ? MicroBlockHeaderSchema.fromJSON(object.header) : undefined,
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0),
      sections: globalThis.Array.isArray(object?.sections)
        ? object.sections.map((e: any) => SectionSchema.fromJSON(e))
        : [],
      feesPayerAccount: isSet(object.feesPayerAccount) ? bytesFromBase64(object.feesPayerAccount) : undefined,
    };
  },

  toJSON(message: MicroBlockSchema): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = MicroBlockHeaderSchema.toJSON(message.header);
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.sections?.length) {
      obj.sections = message.sections.map((e) => SectionSchema.toJSON(e));
    }
    if (message.feesPayerAccount !== undefined) {
      obj.feesPayerAccount = base64FromBytes(message.feesPayerAccount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MicroBlockSchema>, I>>(base?: I): MicroBlockSchema {
    return MicroBlockSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MicroBlockSchema>, I>>(object: I): MicroBlockSchema {
    const message = createBaseMicroBlockSchema();
    message.header = (object.header !== undefined && object.header !== null)
      ? MicroBlockHeaderSchema.fromPartial(object.header)
      : undefined;
    message.hash = object.hash ?? new Uint8Array(0);
    message.sections = object.sections?.map((e) => SectionSchema.fromPartial(e)) || [];
    message.feesPayerAccount = object.feesPayerAccount ?? undefined;
    return message;
  },
};

function createBaseSectionSchema(): SectionSchema {
  return { sectionType: 0, data: undefined };
}

export const SectionSchema: MessageFns<SectionSchema> = {
  encode(message: SectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sectionType !== 0) {
      writer.uint32(8).int32(message.sectionType);
    }
    if (message.data !== undefined) {
      SectionDataSchema.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sectionType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = SectionDataSchema.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SectionSchema {
    return {
      sectionType: isSet(object.sectionType) ? sectionTypeFromJSON(object.sectionType) : 0,
      data: isSet(object.data) ? SectionDataSchema.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: SectionSchema): unknown {
    const obj: any = {};
    if (message.sectionType !== 0) {
      obj.sectionType = sectionTypeToJSON(message.sectionType);
    }
    if (message.data !== undefined) {
      obj.data = SectionDataSchema.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SectionSchema>, I>>(base?: I): SectionSchema {
    return SectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SectionSchema>, I>>(object: I): SectionSchema {
    const message = createBaseSectionSchema();
    message.sectionType = object.sectionType ?? 0;
    message.data = (object.data !== undefined && object.data !== null)
      ? SectionDataSchema.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseSectionDataSchema(): SectionDataSchema {
  return {
    accountSigAlgorithm: undefined,
    accountPublicKey: undefined,
    accountTokenIssuance: undefined,
    accountCreation: undefined,
    accountTransfer: undefined,
    accountSignature: undefined,
    orgSigAlgorithm: undefined,
    orgPublicKey: undefined,
    orgDescription: undefined,
    orgServer: undefined,
    orgSignature: undefined,
    appSigAlgorithm: undefined,
    appDeclaration: undefined,
    appDescription: undefined,
    appSignature: undefined,
    appLedgerSigAlgorithm: undefined,
    appLedgerDeclaration: undefined,
    appLedgerActorCreation: undefined,
    appLedgerChannelCreation: undefined,
    appLedgerSharedSecret: undefined,
    appLedgerChannelInvitation: undefined,
    appLedgerActorSubscription: undefined,
    appLedgerPublicChannelData: undefined,
    appLedgerPrivateChannelData: undefined,
    appLedgerAuthor: undefined,
    appLedgerEndorser: undefined,
    appLedgerEndorserSignature: undefined,
    appLedgerAuthorSignature: undefined,
  };
}

export const SectionDataSchema: MessageFns<SectionDataSchema> = {
  encode(message: SectionDataSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountSigAlgorithm !== undefined) {
      AccountSigAlgorithmSectionSchema.encode(message.accountSigAlgorithm, writer.uint32(18).fork()).join();
    }
    if (message.accountPublicKey !== undefined) {
      AccountPublicKeySectionSchema.encode(message.accountPublicKey, writer.uint32(26).fork()).join();
    }
    if (message.accountTokenIssuance !== undefined) {
      AccountTokenIssuanceSectionSchema.encode(message.accountTokenIssuance, writer.uint32(34).fork()).join();
    }
    if (message.accountCreation !== undefined) {
      AccountCreationSectionSchema.encode(message.accountCreation, writer.uint32(42).fork()).join();
    }
    if (message.accountTransfer !== undefined) {
      AccountTransferSectionSchema.encode(message.accountTransfer, writer.uint32(50).fork()).join();
    }
    if (message.accountSignature !== undefined) {
      AccountSignatureSectionSchema.encode(message.accountSignature, writer.uint32(58).fork()).join();
    }
    if (message.orgSigAlgorithm !== undefined) {
      OrgSigAlgorithmSectionSchema.encode(message.orgSigAlgorithm, writer.uint32(802).fork()).join();
    }
    if (message.orgPublicKey !== undefined) {
      OrgPublicKeySectionSchema.encode(message.orgPublicKey, writer.uint32(810).fork()).join();
    }
    if (message.orgDescription !== undefined) {
      OrgDescriptionSectionSchema.encode(message.orgDescription, writer.uint32(818).fork()).join();
    }
    if (message.orgServer !== undefined) {
      OrgServerSectionSchema.encode(message.orgServer, writer.uint32(826).fork()).join();
    }
    if (message.orgSignature !== undefined) {
      OrgSignatureSectionSchema.encode(message.orgSignature, writer.uint32(834).fork()).join();
    }
    if (message.appSigAlgorithm !== undefined) {
      AppSigAlgorithmSectionSchema.encode(message.appSigAlgorithm, writer.uint32(1602).fork()).join();
    }
    if (message.appDeclaration !== undefined) {
      AppDeclarationSectionSchema.encode(message.appDeclaration, writer.uint32(1610).fork()).join();
    }
    if (message.appDescription !== undefined) {
      AppDescriptionSectionSchema.encode(message.appDescription, writer.uint32(1618).fork()).join();
    }
    if (message.appSignature !== undefined) {
      AppSignatureSectionSchema.encode(message.appSignature, writer.uint32(1626).fork()).join();
    }
    if (message.appLedgerSigAlgorithm !== undefined) {
      AppLedgerSigAlgorithmSectionSchema.encode(message.appLedgerSigAlgorithm, writer.uint32(2402).fork()).join();
    }
    if (message.appLedgerDeclaration !== undefined) {
      AppLedgerDeclarationSectionSchema.encode(message.appLedgerDeclaration, writer.uint32(2410).fork()).join();
    }
    if (message.appLedgerActorCreation !== undefined) {
      AppLedgerActorCreationSectionSchema.encode(message.appLedgerActorCreation, writer.uint32(2418).fork()).join();
    }
    if (message.appLedgerChannelCreation !== undefined) {
      AppLedgerChannelCreationSectionSchema.encode(message.appLedgerChannelCreation, writer.uint32(2426).fork()).join();
    }
    if (message.appLedgerSharedSecret !== undefined) {
      AppLedgerSharedSecretSectionSchema.encode(message.appLedgerSharedSecret, writer.uint32(2434).fork()).join();
    }
    if (message.appLedgerChannelInvitation !== undefined) {
      AppLedgerChannelInvitationSectionSchema.encode(message.appLedgerChannelInvitation, writer.uint32(2442).fork())
        .join();
    }
    if (message.appLedgerActorSubscription !== undefined) {
      AppLedgerActorSubscriptionSectionSchema.encode(message.appLedgerActorSubscription, writer.uint32(2450).fork())
        .join();
    }
    if (message.appLedgerPublicChannelData !== undefined) {
      AppLedgerPublicChannelDataSectionSchema.encode(message.appLedgerPublicChannelData, writer.uint32(2458).fork())
        .join();
    }
    if (message.appLedgerPrivateChannelData !== undefined) {
      AppLedgerPrivateChannelDataSectionSchema.encode(message.appLedgerPrivateChannelData, writer.uint32(2466).fork())
        .join();
    }
    if (message.appLedgerAuthor !== undefined) {
      AppLedgerAuthorSectionSchema.encode(message.appLedgerAuthor, writer.uint32(2474).fork()).join();
    }
    if (message.appLedgerEndorser !== undefined) {
      AppLedgerEndorserSectionSchema.encode(message.appLedgerEndorser, writer.uint32(2482).fork()).join();
    }
    if (message.appLedgerEndorserSignature !== undefined) {
      AppLedgerEndorserSignatureSectionSchema.encode(message.appLedgerEndorserSignature, writer.uint32(2490).fork())
        .join();
    }
    if (message.appLedgerAuthorSignature !== undefined) {
      AppLedgerAuthorSignatureSectionSchema.encode(message.appLedgerAuthorSignature, writer.uint32(2498).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SectionDataSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSectionDataSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountSigAlgorithm = AccountSigAlgorithmSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accountPublicKey = AccountPublicKeySectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accountTokenIssuance = AccountTokenIssuanceSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.accountCreation = AccountCreationSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.accountTransfer = AccountTransferSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.accountSignature = AccountSignatureSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.orgSigAlgorithm = OrgSigAlgorithmSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.orgPublicKey = OrgPublicKeySectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.orgDescription = OrgDescriptionSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 103: {
          if (tag !== 826) {
            break;
          }

          message.orgServer = OrgServerSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 104: {
          if (tag !== 834) {
            break;
          }

          message.orgSignature = OrgSignatureSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 200: {
          if (tag !== 1602) {
            break;
          }

          message.appSigAlgorithm = AppSigAlgorithmSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 201: {
          if (tag !== 1610) {
            break;
          }

          message.appDeclaration = AppDeclarationSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 202: {
          if (tag !== 1618) {
            break;
          }

          message.appDescription = AppDescriptionSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 203: {
          if (tag !== 1626) {
            break;
          }

          message.appSignature = AppSignatureSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 300: {
          if (tag !== 2402) {
            break;
          }

          message.appLedgerSigAlgorithm = AppLedgerSigAlgorithmSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 301: {
          if (tag !== 2410) {
            break;
          }

          message.appLedgerDeclaration = AppLedgerDeclarationSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 302: {
          if (tag !== 2418) {
            break;
          }

          message.appLedgerActorCreation = AppLedgerActorCreationSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 303: {
          if (tag !== 2426) {
            break;
          }

          message.appLedgerChannelCreation = AppLedgerChannelCreationSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 304: {
          if (tag !== 2434) {
            break;
          }

          message.appLedgerSharedSecret = AppLedgerSharedSecretSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 305: {
          if (tag !== 2442) {
            break;
          }

          message.appLedgerChannelInvitation = AppLedgerChannelInvitationSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 306: {
          if (tag !== 2450) {
            break;
          }

          message.appLedgerActorSubscription = AppLedgerActorSubscriptionSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 307: {
          if (tag !== 2458) {
            break;
          }

          message.appLedgerPublicChannelData = AppLedgerPublicChannelDataSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 308: {
          if (tag !== 2466) {
            break;
          }

          message.appLedgerPrivateChannelData = AppLedgerPrivateChannelDataSectionSchema.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 309: {
          if (tag !== 2474) {
            break;
          }

          message.appLedgerAuthor = AppLedgerAuthorSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 310: {
          if (tag !== 2482) {
            break;
          }

          message.appLedgerEndorser = AppLedgerEndorserSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 311: {
          if (tag !== 2490) {
            break;
          }

          message.appLedgerEndorserSignature = AppLedgerEndorserSignatureSectionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 312: {
          if (tag !== 2498) {
            break;
          }

          message.appLedgerAuthorSignature = AppLedgerAuthorSignatureSectionSchema.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SectionDataSchema {
    return {
      accountSigAlgorithm: isSet(object.accountSigAlgorithm)
        ? AccountSigAlgorithmSectionSchema.fromJSON(object.accountSigAlgorithm)
        : undefined,
      accountPublicKey: isSet(object.accountPublicKey)
        ? AccountPublicKeySectionSchema.fromJSON(object.accountPublicKey)
        : undefined,
      accountTokenIssuance: isSet(object.accountTokenIssuance)
        ? AccountTokenIssuanceSectionSchema.fromJSON(object.accountTokenIssuance)
        : undefined,
      accountCreation: isSet(object.accountCreation)
        ? AccountCreationSectionSchema.fromJSON(object.accountCreation)
        : undefined,
      accountTransfer: isSet(object.accountTransfer)
        ? AccountTransferSectionSchema.fromJSON(object.accountTransfer)
        : undefined,
      accountSignature: isSet(object.accountSignature)
        ? AccountSignatureSectionSchema.fromJSON(object.accountSignature)
        : undefined,
      orgSigAlgorithm: isSet(object.orgSigAlgorithm)
        ? OrgSigAlgorithmSectionSchema.fromJSON(object.orgSigAlgorithm)
        : undefined,
      orgPublicKey: isSet(object.orgPublicKey) ? OrgPublicKeySectionSchema.fromJSON(object.orgPublicKey) : undefined,
      orgDescription: isSet(object.orgDescription)
        ? OrgDescriptionSectionSchema.fromJSON(object.orgDescription)
        : undefined,
      orgServer: isSet(object.orgServer) ? OrgServerSectionSchema.fromJSON(object.orgServer) : undefined,
      orgSignature: isSet(object.orgSignature) ? OrgSignatureSectionSchema.fromJSON(object.orgSignature) : undefined,
      appSigAlgorithm: isSet(object.appSigAlgorithm)
        ? AppSigAlgorithmSectionSchema.fromJSON(object.appSigAlgorithm)
        : undefined,
      appDeclaration: isSet(object.appDeclaration)
        ? AppDeclarationSectionSchema.fromJSON(object.appDeclaration)
        : undefined,
      appDescription: isSet(object.appDescription)
        ? AppDescriptionSectionSchema.fromJSON(object.appDescription)
        : undefined,
      appSignature: isSet(object.appSignature) ? AppSignatureSectionSchema.fromJSON(object.appSignature) : undefined,
      appLedgerSigAlgorithm: isSet(object.appLedgerSigAlgorithm)
        ? AppLedgerSigAlgorithmSectionSchema.fromJSON(object.appLedgerSigAlgorithm)
        : undefined,
      appLedgerDeclaration: isSet(object.appLedgerDeclaration)
        ? AppLedgerDeclarationSectionSchema.fromJSON(object.appLedgerDeclaration)
        : undefined,
      appLedgerActorCreation: isSet(object.appLedgerActorCreation)
        ? AppLedgerActorCreationSectionSchema.fromJSON(object.appLedgerActorCreation)
        : undefined,
      appLedgerChannelCreation: isSet(object.appLedgerChannelCreation)
        ? AppLedgerChannelCreationSectionSchema.fromJSON(object.appLedgerChannelCreation)
        : undefined,
      appLedgerSharedSecret: isSet(object.appLedgerSharedSecret)
        ? AppLedgerSharedSecretSectionSchema.fromJSON(object.appLedgerSharedSecret)
        : undefined,
      appLedgerChannelInvitation: isSet(object.appLedgerChannelInvitation)
        ? AppLedgerChannelInvitationSectionSchema.fromJSON(object.appLedgerChannelInvitation)
        : undefined,
      appLedgerActorSubscription: isSet(object.appLedgerActorSubscription)
        ? AppLedgerActorSubscriptionSectionSchema.fromJSON(object.appLedgerActorSubscription)
        : undefined,
      appLedgerPublicChannelData: isSet(object.appLedgerPublicChannelData)
        ? AppLedgerPublicChannelDataSectionSchema.fromJSON(object.appLedgerPublicChannelData)
        : undefined,
      appLedgerPrivateChannelData: isSet(object.appLedgerPrivateChannelData)
        ? AppLedgerPrivateChannelDataSectionSchema.fromJSON(object.appLedgerPrivateChannelData)
        : undefined,
      appLedgerAuthor: isSet(object.appLedgerAuthor)
        ? AppLedgerAuthorSectionSchema.fromJSON(object.appLedgerAuthor)
        : undefined,
      appLedgerEndorser: isSet(object.appLedgerEndorser)
        ? AppLedgerEndorserSectionSchema.fromJSON(object.appLedgerEndorser)
        : undefined,
      appLedgerEndorserSignature: isSet(object.appLedgerEndorserSignature)
        ? AppLedgerEndorserSignatureSectionSchema.fromJSON(object.appLedgerEndorserSignature)
        : undefined,
      appLedgerAuthorSignature: isSet(object.appLedgerAuthorSignature)
        ? AppLedgerAuthorSignatureSectionSchema.fromJSON(object.appLedgerAuthorSignature)
        : undefined,
    };
  },

  toJSON(message: SectionDataSchema): unknown {
    const obj: any = {};
    if (message.accountSigAlgorithm !== undefined) {
      obj.accountSigAlgorithm = AccountSigAlgorithmSectionSchema.toJSON(message.accountSigAlgorithm);
    }
    if (message.accountPublicKey !== undefined) {
      obj.accountPublicKey = AccountPublicKeySectionSchema.toJSON(message.accountPublicKey);
    }
    if (message.accountTokenIssuance !== undefined) {
      obj.accountTokenIssuance = AccountTokenIssuanceSectionSchema.toJSON(message.accountTokenIssuance);
    }
    if (message.accountCreation !== undefined) {
      obj.accountCreation = AccountCreationSectionSchema.toJSON(message.accountCreation);
    }
    if (message.accountTransfer !== undefined) {
      obj.accountTransfer = AccountTransferSectionSchema.toJSON(message.accountTransfer);
    }
    if (message.accountSignature !== undefined) {
      obj.accountSignature = AccountSignatureSectionSchema.toJSON(message.accountSignature);
    }
    if (message.orgSigAlgorithm !== undefined) {
      obj.orgSigAlgorithm = OrgSigAlgorithmSectionSchema.toJSON(message.orgSigAlgorithm);
    }
    if (message.orgPublicKey !== undefined) {
      obj.orgPublicKey = OrgPublicKeySectionSchema.toJSON(message.orgPublicKey);
    }
    if (message.orgDescription !== undefined) {
      obj.orgDescription = OrgDescriptionSectionSchema.toJSON(message.orgDescription);
    }
    if (message.orgServer !== undefined) {
      obj.orgServer = OrgServerSectionSchema.toJSON(message.orgServer);
    }
    if (message.orgSignature !== undefined) {
      obj.orgSignature = OrgSignatureSectionSchema.toJSON(message.orgSignature);
    }
    if (message.appSigAlgorithm !== undefined) {
      obj.appSigAlgorithm = AppSigAlgorithmSectionSchema.toJSON(message.appSigAlgorithm);
    }
    if (message.appDeclaration !== undefined) {
      obj.appDeclaration = AppDeclarationSectionSchema.toJSON(message.appDeclaration);
    }
    if (message.appDescription !== undefined) {
      obj.appDescription = AppDescriptionSectionSchema.toJSON(message.appDescription);
    }
    if (message.appSignature !== undefined) {
      obj.appSignature = AppSignatureSectionSchema.toJSON(message.appSignature);
    }
    if (message.appLedgerSigAlgorithm !== undefined) {
      obj.appLedgerSigAlgorithm = AppLedgerSigAlgorithmSectionSchema.toJSON(message.appLedgerSigAlgorithm);
    }
    if (message.appLedgerDeclaration !== undefined) {
      obj.appLedgerDeclaration = AppLedgerDeclarationSectionSchema.toJSON(message.appLedgerDeclaration);
    }
    if (message.appLedgerActorCreation !== undefined) {
      obj.appLedgerActorCreation = AppLedgerActorCreationSectionSchema.toJSON(message.appLedgerActorCreation);
    }
    if (message.appLedgerChannelCreation !== undefined) {
      obj.appLedgerChannelCreation = AppLedgerChannelCreationSectionSchema.toJSON(message.appLedgerChannelCreation);
    }
    if (message.appLedgerSharedSecret !== undefined) {
      obj.appLedgerSharedSecret = AppLedgerSharedSecretSectionSchema.toJSON(message.appLedgerSharedSecret);
    }
    if (message.appLedgerChannelInvitation !== undefined) {
      obj.appLedgerChannelInvitation = AppLedgerChannelInvitationSectionSchema.toJSON(
        message.appLedgerChannelInvitation,
      );
    }
    if (message.appLedgerActorSubscription !== undefined) {
      obj.appLedgerActorSubscription = AppLedgerActorSubscriptionSectionSchema.toJSON(
        message.appLedgerActorSubscription,
      );
    }
    if (message.appLedgerPublicChannelData !== undefined) {
      obj.appLedgerPublicChannelData = AppLedgerPublicChannelDataSectionSchema.toJSON(
        message.appLedgerPublicChannelData,
      );
    }
    if (message.appLedgerPrivateChannelData !== undefined) {
      obj.appLedgerPrivateChannelData = AppLedgerPrivateChannelDataSectionSchema.toJSON(
        message.appLedgerPrivateChannelData,
      );
    }
    if (message.appLedgerAuthor !== undefined) {
      obj.appLedgerAuthor = AppLedgerAuthorSectionSchema.toJSON(message.appLedgerAuthor);
    }
    if (message.appLedgerEndorser !== undefined) {
      obj.appLedgerEndorser = AppLedgerEndorserSectionSchema.toJSON(message.appLedgerEndorser);
    }
    if (message.appLedgerEndorserSignature !== undefined) {
      obj.appLedgerEndorserSignature = AppLedgerEndorserSignatureSectionSchema.toJSON(
        message.appLedgerEndorserSignature,
      );
    }
    if (message.appLedgerAuthorSignature !== undefined) {
      obj.appLedgerAuthorSignature = AppLedgerAuthorSignatureSectionSchema.toJSON(message.appLedgerAuthorSignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SectionDataSchema>, I>>(base?: I): SectionDataSchema {
    return SectionDataSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SectionDataSchema>, I>>(object: I): SectionDataSchema {
    const message = createBaseSectionDataSchema();
    message.accountSigAlgorithm = (object.accountSigAlgorithm !== undefined && object.accountSigAlgorithm !== null)
      ? AccountSigAlgorithmSectionSchema.fromPartial(object.accountSigAlgorithm)
      : undefined;
    message.accountPublicKey = (object.accountPublicKey !== undefined && object.accountPublicKey !== null)
      ? AccountPublicKeySectionSchema.fromPartial(object.accountPublicKey)
      : undefined;
    message.accountTokenIssuance = (object.accountTokenIssuance !== undefined && object.accountTokenIssuance !== null)
      ? AccountTokenIssuanceSectionSchema.fromPartial(object.accountTokenIssuance)
      : undefined;
    message.accountCreation = (object.accountCreation !== undefined && object.accountCreation !== null)
      ? AccountCreationSectionSchema.fromPartial(object.accountCreation)
      : undefined;
    message.accountTransfer = (object.accountTransfer !== undefined && object.accountTransfer !== null)
      ? AccountTransferSectionSchema.fromPartial(object.accountTransfer)
      : undefined;
    message.accountSignature = (object.accountSignature !== undefined && object.accountSignature !== null)
      ? AccountSignatureSectionSchema.fromPartial(object.accountSignature)
      : undefined;
    message.orgSigAlgorithm = (object.orgSigAlgorithm !== undefined && object.orgSigAlgorithm !== null)
      ? OrgSigAlgorithmSectionSchema.fromPartial(object.orgSigAlgorithm)
      : undefined;
    message.orgPublicKey = (object.orgPublicKey !== undefined && object.orgPublicKey !== null)
      ? OrgPublicKeySectionSchema.fromPartial(object.orgPublicKey)
      : undefined;
    message.orgDescription = (object.orgDescription !== undefined && object.orgDescription !== null)
      ? OrgDescriptionSectionSchema.fromPartial(object.orgDescription)
      : undefined;
    message.orgServer = (object.orgServer !== undefined && object.orgServer !== null)
      ? OrgServerSectionSchema.fromPartial(object.orgServer)
      : undefined;
    message.orgSignature = (object.orgSignature !== undefined && object.orgSignature !== null)
      ? OrgSignatureSectionSchema.fromPartial(object.orgSignature)
      : undefined;
    message.appSigAlgorithm = (object.appSigAlgorithm !== undefined && object.appSigAlgorithm !== null)
      ? AppSigAlgorithmSectionSchema.fromPartial(object.appSigAlgorithm)
      : undefined;
    message.appDeclaration = (object.appDeclaration !== undefined && object.appDeclaration !== null)
      ? AppDeclarationSectionSchema.fromPartial(object.appDeclaration)
      : undefined;
    message.appDescription = (object.appDescription !== undefined && object.appDescription !== null)
      ? AppDescriptionSectionSchema.fromPartial(object.appDescription)
      : undefined;
    message.appSignature = (object.appSignature !== undefined && object.appSignature !== null)
      ? AppSignatureSectionSchema.fromPartial(object.appSignature)
      : undefined;
    message.appLedgerSigAlgorithm =
      (object.appLedgerSigAlgorithm !== undefined && object.appLedgerSigAlgorithm !== null)
        ? AppLedgerSigAlgorithmSectionSchema.fromPartial(object.appLedgerSigAlgorithm)
        : undefined;
    message.appLedgerDeclaration = (object.appLedgerDeclaration !== undefined && object.appLedgerDeclaration !== null)
      ? AppLedgerDeclarationSectionSchema.fromPartial(object.appLedgerDeclaration)
      : undefined;
    message.appLedgerActorCreation =
      (object.appLedgerActorCreation !== undefined && object.appLedgerActorCreation !== null)
        ? AppLedgerActorCreationSectionSchema.fromPartial(object.appLedgerActorCreation)
        : undefined;
    message.appLedgerChannelCreation =
      (object.appLedgerChannelCreation !== undefined && object.appLedgerChannelCreation !== null)
        ? AppLedgerChannelCreationSectionSchema.fromPartial(object.appLedgerChannelCreation)
        : undefined;
    message.appLedgerSharedSecret =
      (object.appLedgerSharedSecret !== undefined && object.appLedgerSharedSecret !== null)
        ? AppLedgerSharedSecretSectionSchema.fromPartial(object.appLedgerSharedSecret)
        : undefined;
    message.appLedgerChannelInvitation =
      (object.appLedgerChannelInvitation !== undefined && object.appLedgerChannelInvitation !== null)
        ? AppLedgerChannelInvitationSectionSchema.fromPartial(object.appLedgerChannelInvitation)
        : undefined;
    message.appLedgerActorSubscription =
      (object.appLedgerActorSubscription !== undefined && object.appLedgerActorSubscription !== null)
        ? AppLedgerActorSubscriptionSectionSchema.fromPartial(object.appLedgerActorSubscription)
        : undefined;
    message.appLedgerPublicChannelData =
      (object.appLedgerPublicChannelData !== undefined && object.appLedgerPublicChannelData !== null)
        ? AppLedgerPublicChannelDataSectionSchema.fromPartial(object.appLedgerPublicChannelData)
        : undefined;
    message.appLedgerPrivateChannelData =
      (object.appLedgerPrivateChannelData !== undefined && object.appLedgerPrivateChannelData !== null)
        ? AppLedgerPrivateChannelDataSectionSchema.fromPartial(object.appLedgerPrivateChannelData)
        : undefined;
    message.appLedgerAuthor = (object.appLedgerAuthor !== undefined && object.appLedgerAuthor !== null)
      ? AppLedgerAuthorSectionSchema.fromPartial(object.appLedgerAuthor)
      : undefined;
    message.appLedgerEndorser = (object.appLedgerEndorser !== undefined && object.appLedgerEndorser !== null)
      ? AppLedgerEndorserSectionSchema.fromPartial(object.appLedgerEndorser)
      : undefined;
    message.appLedgerEndorserSignature =
      (object.appLedgerEndorserSignature !== undefined && object.appLedgerEndorserSignature !== null)
        ? AppLedgerEndorserSignatureSectionSchema.fromPartial(object.appLedgerEndorserSignature)
        : undefined;
    message.appLedgerAuthorSignature =
      (object.appLedgerAuthorSignature !== undefined && object.appLedgerAuthorSignature !== null)
        ? AppLedgerAuthorSignatureSectionSchema.fromPartial(object.appLedgerAuthorSignature)
        : undefined;
    return message;
  },
};

function createBaseAccountSigAlgorithmSectionSchema(): AccountSigAlgorithmSectionSchema {
  return { algorithmId: 0 };
}

export const AccountSigAlgorithmSectionSchema: MessageFns<AccountSigAlgorithmSectionSchema> = {
  encode(message: AccountSigAlgorithmSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithmId !== 0) {
      writer.uint32(8).uint32(message.algorithmId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountSigAlgorithmSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSigAlgorithmSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.algorithmId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSigAlgorithmSectionSchema {
    return { algorithmId: isSet(object.algorithmId) ? globalThis.Number(object.algorithmId) : 0 };
  },

  toJSON(message: AccountSigAlgorithmSectionSchema): unknown {
    const obj: any = {};
    if (message.algorithmId !== 0) {
      obj.algorithmId = Math.round(message.algorithmId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountSigAlgorithmSectionSchema>, I>>(
    base?: I,
  ): AccountSigAlgorithmSectionSchema {
    return AccountSigAlgorithmSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountSigAlgorithmSectionSchema>, I>>(
    object: I,
  ): AccountSigAlgorithmSectionSchema {
    const message = createBaseAccountSigAlgorithmSectionSchema();
    message.algorithmId = object.algorithmId ?? 0;
    return message;
  },
};

function createBaseAccountPublicKeySectionSchema(): AccountPublicKeySectionSchema {
  return { publicKey: new Uint8Array(0) };
}

export const AccountPublicKeySectionSchema: MessageFns<AccountPublicKeySectionSchema> = {
  encode(message: AccountPublicKeySectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey.length !== 0) {
      writer.uint32(10).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountPublicKeySectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountPublicKeySectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountPublicKeySectionSchema {
    return { publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0) };
  },

  toJSON(message: AccountPublicKeySectionSchema): unknown {
    const obj: any = {};
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountPublicKeySectionSchema>, I>>(base?: I): AccountPublicKeySectionSchema {
    return AccountPublicKeySectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountPublicKeySectionSchema>, I>>(
    object: I,
  ): AccountPublicKeySectionSchema {
    const message = createBaseAccountPublicKeySectionSchema();
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAccountTokenIssuanceSectionSchema(): AccountTokenIssuanceSectionSchema {
  return { amount: 0 };
}

export const AccountTokenIssuanceSectionSchema: MessageFns<AccountTokenIssuanceSectionSchema> = {
  encode(message: AccountTokenIssuanceSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== 0) {
      writer.uint32(8).uint64(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountTokenIssuanceSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountTokenIssuanceSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.amount = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountTokenIssuanceSectionSchema {
    return { amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0 };
  },

  toJSON(message: AccountTokenIssuanceSectionSchema): unknown {
    const obj: any = {};
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountTokenIssuanceSectionSchema>, I>>(
    base?: I,
  ): AccountTokenIssuanceSectionSchema {
    return AccountTokenIssuanceSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountTokenIssuanceSectionSchema>, I>>(
    object: I,
  ): AccountTokenIssuanceSectionSchema {
    const message = createBaseAccountTokenIssuanceSectionSchema();
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseAccountCreationSectionSchema(): AccountCreationSectionSchema {
  return { sellerAccount: new Uint8Array(0), amount: 0 };
}

export const AccountCreationSectionSchema: MessageFns<AccountCreationSectionSchema> = {
  encode(message: AccountCreationSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sellerAccount.length !== 0) {
      writer.uint32(10).bytes(message.sellerAccount);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint64(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountCreationSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountCreationSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sellerAccount = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountCreationSectionSchema {
    return {
      sellerAccount: isSet(object.sellerAccount) ? bytesFromBase64(object.sellerAccount) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: AccountCreationSectionSchema): unknown {
    const obj: any = {};
    if (message.sellerAccount.length !== 0) {
      obj.sellerAccount = base64FromBytes(message.sellerAccount);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountCreationSectionSchema>, I>>(base?: I): AccountCreationSectionSchema {
    return AccountCreationSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountCreationSectionSchema>, I>>(object: I): AccountCreationSectionSchema {
    const message = createBaseAccountCreationSectionSchema();
    message.sellerAccount = object.sellerAccount ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseAccountTransferSectionSchema(): AccountTransferSectionSchema {
  return { account: new Uint8Array(0), amount: 0, publicReference: "", privateReference: "" };
}

export const AccountTransferSectionSchema: MessageFns<AccountTransferSectionSchema> = {
  encode(message: AccountTransferSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account.length !== 0) {
      writer.uint32(10).bytes(message.account);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint64(message.amount);
    }
    if (message.publicReference !== "") {
      writer.uint32(26).string(message.publicReference);
    }
    if (message.privateReference !== "") {
      writer.uint32(34).string(message.privateReference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountTransferSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountTransferSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicReference = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.privateReference = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountTransferSectionSchema {
    return {
      account: isSet(object.account) ? bytesFromBase64(object.account) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      publicReference: isSet(object.publicReference) ? globalThis.String(object.publicReference) : "",
      privateReference: isSet(object.privateReference) ? globalThis.String(object.privateReference) : "",
    };
  },

  toJSON(message: AccountTransferSectionSchema): unknown {
    const obj: any = {};
    if (message.account.length !== 0) {
      obj.account = base64FromBytes(message.account);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.publicReference !== "") {
      obj.publicReference = message.publicReference;
    }
    if (message.privateReference !== "") {
      obj.privateReference = message.privateReference;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountTransferSectionSchema>, I>>(base?: I): AccountTransferSectionSchema {
    return AccountTransferSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountTransferSectionSchema>, I>>(object: I): AccountTransferSectionSchema {
    const message = createBaseAccountTransferSectionSchema();
    message.account = object.account ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.publicReference = object.publicReference ?? "";
    message.privateReference = object.privateReference ?? "";
    return message;
  },
};

function createBaseAccountSignatureSectionSchema(): AccountSignatureSectionSchema {
  return { signature: new Uint8Array(0) };
}

export const AccountSignatureSectionSchema: MessageFns<AccountSignatureSectionSchema> = {
  encode(message: AccountSignatureSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountSignatureSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSignatureSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountSignatureSectionSchema {
    return { signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0) };
  },

  toJSON(message: AccountSignatureSectionSchema): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountSignatureSectionSchema>, I>>(base?: I): AccountSignatureSectionSchema {
    return AccountSignatureSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountSignatureSectionSchema>, I>>(
    object: I,
  ): AccountSignatureSectionSchema {
    const message = createBaseAccountSignatureSectionSchema();
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseOrgSigAlgorithmSectionSchema(): OrgSigAlgorithmSectionSchema {
  return { algorithmId: 0 };
}

export const OrgSigAlgorithmSectionSchema: MessageFns<OrgSigAlgorithmSectionSchema> = {
  encode(message: OrgSigAlgorithmSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithmId !== 0) {
      writer.uint32(8).uint32(message.algorithmId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrgSigAlgorithmSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrgSigAlgorithmSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.algorithmId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrgSigAlgorithmSectionSchema {
    return { algorithmId: isSet(object.algorithmId) ? globalThis.Number(object.algorithmId) : 0 };
  },

  toJSON(message: OrgSigAlgorithmSectionSchema): unknown {
    const obj: any = {};
    if (message.algorithmId !== 0) {
      obj.algorithmId = Math.round(message.algorithmId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrgSigAlgorithmSectionSchema>, I>>(base?: I): OrgSigAlgorithmSectionSchema {
    return OrgSigAlgorithmSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrgSigAlgorithmSectionSchema>, I>>(object: I): OrgSigAlgorithmSectionSchema {
    const message = createBaseOrgSigAlgorithmSectionSchema();
    message.algorithmId = object.algorithmId ?? 0;
    return message;
  },
};

function createBaseOrgPublicKeySectionSchema(): OrgPublicKeySectionSchema {
  return { publicKey: new Uint8Array(0) };
}

export const OrgPublicKeySectionSchema: MessageFns<OrgPublicKeySectionSchema> = {
  encode(message: OrgPublicKeySectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey.length !== 0) {
      writer.uint32(10).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrgPublicKeySectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrgPublicKeySectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrgPublicKeySectionSchema {
    return { publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0) };
  },

  toJSON(message: OrgPublicKeySectionSchema): unknown {
    const obj: any = {};
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrgPublicKeySectionSchema>, I>>(base?: I): OrgPublicKeySectionSchema {
    return OrgPublicKeySectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrgPublicKeySectionSchema>, I>>(object: I): OrgPublicKeySectionSchema {
    const message = createBaseOrgPublicKeySectionSchema();
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseOrgDescriptionSectionSchema(): OrgDescriptionSectionSchema {
  return { name: "", city: "", countryCode: "", website: "" };
}

export const OrgDescriptionSectionSchema: MessageFns<OrgDescriptionSectionSchema> = {
  encode(message: OrgDescriptionSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.city !== "") {
      writer.uint32(18).string(message.city);
    }
    if (message.countryCode !== "") {
      writer.uint32(26).string(message.countryCode);
    }
    if (message.website !== "") {
      writer.uint32(34).string(message.website);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrgDescriptionSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrgDescriptionSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.website = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrgDescriptionSectionSchema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      website: isSet(object.website) ? globalThis.String(object.website) : "",
    };
  },

  toJSON(message: OrgDescriptionSectionSchema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.website !== "") {
      obj.website = message.website;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrgDescriptionSectionSchema>, I>>(base?: I): OrgDescriptionSectionSchema {
    return OrgDescriptionSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrgDescriptionSectionSchema>, I>>(object: I): OrgDescriptionSectionSchema {
    const message = createBaseOrgDescriptionSectionSchema();
    message.name = object.name ?? "";
    message.city = object.city ?? "";
    message.countryCode = object.countryCode ?? "";
    message.website = object.website ?? "";
    return message;
  },
};

function createBaseOrgServerSectionSchema(): OrgServerSectionSchema {
  return { endpoint: "" };
}

export const OrgServerSectionSchema: MessageFns<OrgServerSectionSchema> = {
  encode(message: OrgServerSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoint !== "") {
      writer.uint32(10).string(message.endpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrgServerSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrgServerSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrgServerSectionSchema {
    return { endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "" };
  },

  toJSON(message: OrgServerSectionSchema): unknown {
    const obj: any = {};
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrgServerSectionSchema>, I>>(base?: I): OrgServerSectionSchema {
    return OrgServerSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrgServerSectionSchema>, I>>(object: I): OrgServerSectionSchema {
    const message = createBaseOrgServerSectionSchema();
    message.endpoint = object.endpoint ?? "";
    return message;
  },
};

function createBaseOrgSignatureSectionSchema(): OrgSignatureSectionSchema {
  return { signature: new Uint8Array(0) };
}

export const OrgSignatureSectionSchema: MessageFns<OrgSignatureSectionSchema> = {
  encode(message: OrgSignatureSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrgSignatureSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrgSignatureSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrgSignatureSectionSchema {
    return { signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0) };
  },

  toJSON(message: OrgSignatureSectionSchema): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrgSignatureSectionSchema>, I>>(base?: I): OrgSignatureSectionSchema {
    return OrgSignatureSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrgSignatureSectionSchema>, I>>(object: I): OrgSignatureSectionSchema {
    const message = createBaseOrgSignatureSectionSchema();
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAppSigAlgorithmSectionSchema(): AppSigAlgorithmSectionSchema {
  return { algorithmId: 0 };
}

export const AppSigAlgorithmSectionSchema: MessageFns<AppSigAlgorithmSectionSchema> = {
  encode(message: AppSigAlgorithmSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithmId !== 0) {
      writer.uint32(8).uint32(message.algorithmId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppSigAlgorithmSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppSigAlgorithmSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.algorithmId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppSigAlgorithmSectionSchema {
    return { algorithmId: isSet(object.algorithmId) ? globalThis.Number(object.algorithmId) : 0 };
  },

  toJSON(message: AppSigAlgorithmSectionSchema): unknown {
    const obj: any = {};
    if (message.algorithmId !== 0) {
      obj.algorithmId = Math.round(message.algorithmId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppSigAlgorithmSectionSchema>, I>>(base?: I): AppSigAlgorithmSectionSchema {
    return AppSigAlgorithmSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppSigAlgorithmSectionSchema>, I>>(object: I): AppSigAlgorithmSectionSchema {
    const message = createBaseAppSigAlgorithmSectionSchema();
    message.algorithmId = object.algorithmId ?? 0;
    return message;
  },
};

function createBaseAppDeclarationSectionSchema(): AppDeclarationSectionSchema {
  return { organizationId: new Uint8Array(0) };
}

export const AppDeclarationSectionSchema: MessageFns<AppDeclarationSectionSchema> = {
  encode(message: AppDeclarationSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organizationId.length !== 0) {
      writer.uint32(10).bytes(message.organizationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppDeclarationSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppDeclarationSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organizationId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppDeclarationSectionSchema {
    return {
      organizationId: isSet(object.organizationId) ? bytesFromBase64(object.organizationId) : new Uint8Array(0),
    };
  },

  toJSON(message: AppDeclarationSectionSchema): unknown {
    const obj: any = {};
    if (message.organizationId.length !== 0) {
      obj.organizationId = base64FromBytes(message.organizationId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppDeclarationSectionSchema>, I>>(base?: I): AppDeclarationSectionSchema {
    return AppDeclarationSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppDeclarationSectionSchema>, I>>(object: I): AppDeclarationSectionSchema {
    const message = createBaseAppDeclarationSectionSchema();
    message.organizationId = object.organizationId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAppDescriptionSectionSchema(): AppDescriptionSectionSchema {
  return { name: "", logoUrl: "", homepageUrl: "", description: "" };
}

export const AppDescriptionSectionSchema: MessageFns<AppDescriptionSectionSchema> = {
  encode(message: AppDescriptionSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.logoUrl !== "") {
      writer.uint32(18).string(message.logoUrl);
    }
    if (message.homepageUrl !== "") {
      writer.uint32(26).string(message.homepageUrl);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppDescriptionSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppDescriptionSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.logoUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.homepageUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppDescriptionSectionSchema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      logoUrl: isSet(object.logoUrl) ? globalThis.String(object.logoUrl) : "",
      homepageUrl: isSet(object.homepageUrl) ? globalThis.String(object.homepageUrl) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: AppDescriptionSectionSchema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.logoUrl !== "") {
      obj.logoUrl = message.logoUrl;
    }
    if (message.homepageUrl !== "") {
      obj.homepageUrl = message.homepageUrl;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppDescriptionSectionSchema>, I>>(base?: I): AppDescriptionSectionSchema {
    return AppDescriptionSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppDescriptionSectionSchema>, I>>(object: I): AppDescriptionSectionSchema {
    const message = createBaseAppDescriptionSectionSchema();
    message.name = object.name ?? "";
    message.logoUrl = object.logoUrl ?? "";
    message.homepageUrl = object.homepageUrl ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseAppSignatureSectionSchema(): AppSignatureSectionSchema {
  return { signature: new Uint8Array(0) };
}

export const AppSignatureSectionSchema: MessageFns<AppSignatureSectionSchema> = {
  encode(message: AppSignatureSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppSignatureSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppSignatureSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppSignatureSectionSchema {
    return { signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0) };
  },

  toJSON(message: AppSignatureSectionSchema): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppSignatureSectionSchema>, I>>(base?: I): AppSignatureSectionSchema {
    return AppSignatureSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppSignatureSectionSchema>, I>>(object: I): AppSignatureSectionSchema {
    const message = createBaseAppSignatureSectionSchema();
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAppLedgerSigAlgorithmSectionSchema(): AppLedgerSigAlgorithmSectionSchema {
  return { algorithmId: 0 };
}

export const AppLedgerSigAlgorithmSectionSchema: MessageFns<AppLedgerSigAlgorithmSectionSchema> = {
  encode(message: AppLedgerSigAlgorithmSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithmId !== 0) {
      writer.uint32(8).uint32(message.algorithmId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerSigAlgorithmSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerSigAlgorithmSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.algorithmId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerSigAlgorithmSectionSchema {
    return { algorithmId: isSet(object.algorithmId) ? globalThis.Number(object.algorithmId) : 0 };
  },

  toJSON(message: AppLedgerSigAlgorithmSectionSchema): unknown {
    const obj: any = {};
    if (message.algorithmId !== 0) {
      obj.algorithmId = Math.round(message.algorithmId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerSigAlgorithmSectionSchema>, I>>(
    base?: I,
  ): AppLedgerSigAlgorithmSectionSchema {
    return AppLedgerSigAlgorithmSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerSigAlgorithmSectionSchema>, I>>(
    object: I,
  ): AppLedgerSigAlgorithmSectionSchema {
    const message = createBaseAppLedgerSigAlgorithmSectionSchema();
    message.algorithmId = object.algorithmId ?? 0;
    return message;
  },
};

function createBaseAppLedgerDeclarationSectionSchema(): AppLedgerDeclarationSectionSchema {
  return { applicationId: new Uint8Array(0) };
}

export const AppLedgerDeclarationSectionSchema: MessageFns<AppLedgerDeclarationSectionSchema> = {
  encode(message: AppLedgerDeclarationSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applicationId.length !== 0) {
      writer.uint32(10).bytes(message.applicationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerDeclarationSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerDeclarationSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applicationId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerDeclarationSectionSchema {
    return { applicationId: isSet(object.applicationId) ? bytesFromBase64(object.applicationId) : new Uint8Array(0) };
  },

  toJSON(message: AppLedgerDeclarationSectionSchema): unknown {
    const obj: any = {};
    if (message.applicationId.length !== 0) {
      obj.applicationId = base64FromBytes(message.applicationId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerDeclarationSectionSchema>, I>>(
    base?: I,
  ): AppLedgerDeclarationSectionSchema {
    return AppLedgerDeclarationSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerDeclarationSectionSchema>, I>>(
    object: I,
  ): AppLedgerDeclarationSectionSchema {
    const message = createBaseAppLedgerDeclarationSectionSchema();
    message.applicationId = object.applicationId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAppLedgerActorCreationSectionSchema(): AppLedgerActorCreationSectionSchema {
  return { id: 0, type: 0, name: "" };
}

export const AppLedgerActorCreationSectionSchema: MessageFns<AppLedgerActorCreationSectionSchema> = {
  encode(message: AppLedgerActorCreationSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).uint32(message.type);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerActorCreationSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerActorCreationSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerActorCreationSectionSchema {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: AppLedgerActorCreationSectionSchema): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerActorCreationSectionSchema>, I>>(
    base?: I,
  ): AppLedgerActorCreationSectionSchema {
    return AppLedgerActorCreationSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerActorCreationSectionSchema>, I>>(
    object: I,
  ): AppLedgerActorCreationSectionSchema {
    const message = createBaseAppLedgerActorCreationSectionSchema();
    message.id = object.id ?? 0;
    message.type = object.type ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAppLedgerChannelCreationSectionSchema(): AppLedgerChannelCreationSectionSchema {
  return { id: 0, isPrivate: false, creatorId: 0, name: "" };
}

export const AppLedgerChannelCreationSectionSchema: MessageFns<AppLedgerChannelCreationSectionSchema> = {
  encode(message: AppLedgerChannelCreationSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.isPrivate !== false) {
      writer.uint32(16).bool(message.isPrivate);
    }
    if (message.creatorId !== 0) {
      writer.uint32(24).uint32(message.creatorId);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerChannelCreationSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerChannelCreationSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isPrivate = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.creatorId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerChannelCreationSectionSchema {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      isPrivate: isSet(object.isPrivate) ? globalThis.Boolean(object.isPrivate) : false,
      creatorId: isSet(object.creatorId) ? globalThis.Number(object.creatorId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: AppLedgerChannelCreationSectionSchema): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.isPrivate !== false) {
      obj.isPrivate = message.isPrivate;
    }
    if (message.creatorId !== 0) {
      obj.creatorId = Math.round(message.creatorId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerChannelCreationSectionSchema>, I>>(
    base?: I,
  ): AppLedgerChannelCreationSectionSchema {
    return AppLedgerChannelCreationSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerChannelCreationSectionSchema>, I>>(
    object: I,
  ): AppLedgerChannelCreationSectionSchema {
    const message = createBaseAppLedgerChannelCreationSectionSchema();
    message.id = object.id ?? 0;
    message.isPrivate = object.isPrivate ?? false;
    message.creatorId = object.creatorId ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAppLedgerSharedSecretSectionSchema(): AppLedgerSharedSecretSectionSchema {
  return { hostId: 0, guestId: 0, encapsulation: new Uint8Array(0) };
}

export const AppLedgerSharedSecretSectionSchema: MessageFns<AppLedgerSharedSecretSectionSchema> = {
  encode(message: AppLedgerSharedSecretSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostId !== 0) {
      writer.uint32(8).uint32(message.hostId);
    }
    if (message.guestId !== 0) {
      writer.uint32(16).uint32(message.guestId);
    }
    if (message.encapsulation.length !== 0) {
      writer.uint32(26).bytes(message.encapsulation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerSharedSecretSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerSharedSecretSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hostId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.guestId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.encapsulation = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerSharedSecretSectionSchema {
    return {
      hostId: isSet(object.hostId) ? globalThis.Number(object.hostId) : 0,
      guestId: isSet(object.guestId) ? globalThis.Number(object.guestId) : 0,
      encapsulation: isSet(object.encapsulation) ? bytesFromBase64(object.encapsulation) : new Uint8Array(0),
    };
  },

  toJSON(message: AppLedgerSharedSecretSectionSchema): unknown {
    const obj: any = {};
    if (message.hostId !== 0) {
      obj.hostId = Math.round(message.hostId);
    }
    if (message.guestId !== 0) {
      obj.guestId = Math.round(message.guestId);
    }
    if (message.encapsulation.length !== 0) {
      obj.encapsulation = base64FromBytes(message.encapsulation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerSharedSecretSectionSchema>, I>>(
    base?: I,
  ): AppLedgerSharedSecretSectionSchema {
    return AppLedgerSharedSecretSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerSharedSecretSectionSchema>, I>>(
    object: I,
  ): AppLedgerSharedSecretSectionSchema {
    const message = createBaseAppLedgerSharedSecretSectionSchema();
    message.hostId = object.hostId ?? 0;
    message.guestId = object.guestId ?? 0;
    message.encapsulation = object.encapsulation ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAppLedgerChannelInvitationSectionSchema(): AppLedgerChannelInvitationSectionSchema {
  return { channelId: 0, hostId: 0, guestId: 0, channelKey: new Uint8Array(0) };
}

export const AppLedgerChannelInvitationSectionSchema: MessageFns<AppLedgerChannelInvitationSectionSchema> = {
  encode(message: AppLedgerChannelInvitationSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== 0) {
      writer.uint32(8).uint32(message.channelId);
    }
    if (message.hostId !== 0) {
      writer.uint32(16).uint32(message.hostId);
    }
    if (message.guestId !== 0) {
      writer.uint32(24).uint32(message.guestId);
    }
    if (message.channelKey.length !== 0) {
      writer.uint32(34).bytes(message.channelKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerChannelInvitationSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerChannelInvitationSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channelId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hostId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.guestId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.channelKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerChannelInvitationSectionSchema {
    return {
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
      hostId: isSet(object.hostId) ? globalThis.Number(object.hostId) : 0,
      guestId: isSet(object.guestId) ? globalThis.Number(object.guestId) : 0,
      channelKey: isSet(object.channelKey) ? bytesFromBase64(object.channelKey) : new Uint8Array(0),
    };
  },

  toJSON(message: AppLedgerChannelInvitationSectionSchema): unknown {
    const obj: any = {};
    if (message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    if (message.hostId !== 0) {
      obj.hostId = Math.round(message.hostId);
    }
    if (message.guestId !== 0) {
      obj.guestId = Math.round(message.guestId);
    }
    if (message.channelKey.length !== 0) {
      obj.channelKey = base64FromBytes(message.channelKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerChannelInvitationSectionSchema>, I>>(
    base?: I,
  ): AppLedgerChannelInvitationSectionSchema {
    return AppLedgerChannelInvitationSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerChannelInvitationSectionSchema>, I>>(
    object: I,
  ): AppLedgerChannelInvitationSectionSchema {
    const message = createBaseAppLedgerChannelInvitationSectionSchema();
    message.channelId = object.channelId ?? 0;
    message.hostId = object.hostId ?? 0;
    message.guestId = object.guestId ?? 0;
    message.channelKey = object.channelKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAppLedgerActorSubscriptionSectionSchema(): AppLedgerActorSubscriptionSectionSchema {
  return {
    actorId: 0,
    actorType: 0,
    organizationId: new Uint8Array(0),
    kemPublicKey: new Uint8Array(0),
    signaturePublicKey: new Uint8Array(0),
  };
}

export const AppLedgerActorSubscriptionSectionSchema: MessageFns<AppLedgerActorSubscriptionSectionSchema> = {
  encode(message: AppLedgerActorSubscriptionSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actorId !== 0) {
      writer.uint32(8).uint32(message.actorId);
    }
    if (message.actorType !== 0) {
      writer.uint32(16).uint32(message.actorType);
    }
    if (message.organizationId.length !== 0) {
      writer.uint32(26).bytes(message.organizationId);
    }
    if (message.kemPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.kemPublicKey);
    }
    if (message.signaturePublicKey.length !== 0) {
      writer.uint32(42).bytes(message.signaturePublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerActorSubscriptionSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerActorSubscriptionSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.actorId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actorType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organizationId = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.kemPublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signaturePublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerActorSubscriptionSectionSchema {
    return {
      actorId: isSet(object.actorId) ? globalThis.Number(object.actorId) : 0,
      actorType: isSet(object.actorType) ? globalThis.Number(object.actorType) : 0,
      organizationId: isSet(object.organizationId) ? bytesFromBase64(object.organizationId) : new Uint8Array(0),
      kemPublicKey: isSet(object.kemPublicKey) ? bytesFromBase64(object.kemPublicKey) : new Uint8Array(0),
      signaturePublicKey: isSet(object.signaturePublicKey)
        ? bytesFromBase64(object.signaturePublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: AppLedgerActorSubscriptionSectionSchema): unknown {
    const obj: any = {};
    if (message.actorId !== 0) {
      obj.actorId = Math.round(message.actorId);
    }
    if (message.actorType !== 0) {
      obj.actorType = Math.round(message.actorType);
    }
    if (message.organizationId.length !== 0) {
      obj.organizationId = base64FromBytes(message.organizationId);
    }
    if (message.kemPublicKey.length !== 0) {
      obj.kemPublicKey = base64FromBytes(message.kemPublicKey);
    }
    if (message.signaturePublicKey.length !== 0) {
      obj.signaturePublicKey = base64FromBytes(message.signaturePublicKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerActorSubscriptionSectionSchema>, I>>(
    base?: I,
  ): AppLedgerActorSubscriptionSectionSchema {
    return AppLedgerActorSubscriptionSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerActorSubscriptionSectionSchema>, I>>(
    object: I,
  ): AppLedgerActorSubscriptionSectionSchema {
    const message = createBaseAppLedgerActorSubscriptionSectionSchema();
    message.actorId = object.actorId ?? 0;
    message.actorType = object.actorType ?? 0;
    message.organizationId = object.organizationId ?? new Uint8Array(0);
    message.kemPublicKey = object.kemPublicKey ?? new Uint8Array(0);
    message.signaturePublicKey = object.signaturePublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAppLedgerPublicChannelDataSectionSchema(): AppLedgerPublicChannelDataSectionSchema {
  return { channelId: 0, data: new Uint8Array(0) };
}

export const AppLedgerPublicChannelDataSectionSchema: MessageFns<AppLedgerPublicChannelDataSectionSchema> = {
  encode(message: AppLedgerPublicChannelDataSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== 0) {
      writer.uint32(8).uint32(message.channelId);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerPublicChannelDataSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerPublicChannelDataSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channelId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerPublicChannelDataSectionSchema {
    return {
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: AppLedgerPublicChannelDataSectionSchema): unknown {
    const obj: any = {};
    if (message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerPublicChannelDataSectionSchema>, I>>(
    base?: I,
  ): AppLedgerPublicChannelDataSectionSchema {
    return AppLedgerPublicChannelDataSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerPublicChannelDataSectionSchema>, I>>(
    object: I,
  ): AppLedgerPublicChannelDataSectionSchema {
    const message = createBaseAppLedgerPublicChannelDataSectionSchema();
    message.channelId = object.channelId ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAppLedgerPrivateChannelDataSectionSchema(): AppLedgerPrivateChannelDataSectionSchema {
  return { channelId: 0, merkleRootHash: new Uint8Array(0), encryptedData: new Uint8Array(0) };
}

export const AppLedgerPrivateChannelDataSectionSchema: MessageFns<AppLedgerPrivateChannelDataSectionSchema> = {
  encode(message: AppLedgerPrivateChannelDataSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== 0) {
      writer.uint32(8).uint32(message.channelId);
    }
    if (message.merkleRootHash.length !== 0) {
      writer.uint32(18).bytes(message.merkleRootHash);
    }
    if (message.encryptedData.length !== 0) {
      writer.uint32(26).bytes(message.encryptedData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerPrivateChannelDataSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerPrivateChannelDataSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channelId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.merkleRootHash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.encryptedData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerPrivateChannelDataSectionSchema {
    return {
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
      merkleRootHash: isSet(object.merkleRootHash) ? bytesFromBase64(object.merkleRootHash) : new Uint8Array(0),
      encryptedData: isSet(object.encryptedData) ? bytesFromBase64(object.encryptedData) : new Uint8Array(0),
    };
  },

  toJSON(message: AppLedgerPrivateChannelDataSectionSchema): unknown {
    const obj: any = {};
    if (message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    if (message.merkleRootHash.length !== 0) {
      obj.merkleRootHash = base64FromBytes(message.merkleRootHash);
    }
    if (message.encryptedData.length !== 0) {
      obj.encryptedData = base64FromBytes(message.encryptedData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerPrivateChannelDataSectionSchema>, I>>(
    base?: I,
  ): AppLedgerPrivateChannelDataSectionSchema {
    return AppLedgerPrivateChannelDataSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerPrivateChannelDataSectionSchema>, I>>(
    object: I,
  ): AppLedgerPrivateChannelDataSectionSchema {
    const message = createBaseAppLedgerPrivateChannelDataSectionSchema();
    message.channelId = object.channelId ?? 0;
    message.merkleRootHash = object.merkleRootHash ?? new Uint8Array(0);
    message.encryptedData = object.encryptedData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAppLedgerAuthorSectionSchema(): AppLedgerAuthorSectionSchema {
  return { authorId: 0 };
}

export const AppLedgerAuthorSectionSchema: MessageFns<AppLedgerAuthorSectionSchema> = {
  encode(message: AppLedgerAuthorSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authorId !== 0) {
      writer.uint32(8).uint32(message.authorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerAuthorSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerAuthorSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.authorId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerAuthorSectionSchema {
    return { authorId: isSet(object.authorId) ? globalThis.Number(object.authorId) : 0 };
  },

  toJSON(message: AppLedgerAuthorSectionSchema): unknown {
    const obj: any = {};
    if (message.authorId !== 0) {
      obj.authorId = Math.round(message.authorId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerAuthorSectionSchema>, I>>(base?: I): AppLedgerAuthorSectionSchema {
    return AppLedgerAuthorSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerAuthorSectionSchema>, I>>(object: I): AppLedgerAuthorSectionSchema {
    const message = createBaseAppLedgerAuthorSectionSchema();
    message.authorId = object.authorId ?? 0;
    return message;
  },
};

function createBaseAppLedgerEndorserSectionSchema(): AppLedgerEndorserSectionSchema {
  return { endorserId: 0, messageId: 0 };
}

export const AppLedgerEndorserSectionSchema: MessageFns<AppLedgerEndorserSectionSchema> = {
  encode(message: AppLedgerEndorserSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endorserId !== 0) {
      writer.uint32(8).uint32(message.endorserId);
    }
    if (message.messageId !== 0) {
      writer.uint32(16).uint32(message.messageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerEndorserSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerEndorserSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.endorserId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.messageId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerEndorserSectionSchema {
    return {
      endorserId: isSet(object.endorserId) ? globalThis.Number(object.endorserId) : 0,
      messageId: isSet(object.messageId) ? globalThis.Number(object.messageId) : 0,
    };
  },

  toJSON(message: AppLedgerEndorserSectionSchema): unknown {
    const obj: any = {};
    if (message.endorserId !== 0) {
      obj.endorserId = Math.round(message.endorserId);
    }
    if (message.messageId !== 0) {
      obj.messageId = Math.round(message.messageId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerEndorserSectionSchema>, I>>(base?: I): AppLedgerEndorserSectionSchema {
    return AppLedgerEndorserSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerEndorserSectionSchema>, I>>(
    object: I,
  ): AppLedgerEndorserSectionSchema {
    const message = createBaseAppLedgerEndorserSectionSchema();
    message.endorserId = object.endorserId ?? 0;
    message.messageId = object.messageId ?? 0;
    return message;
  },
};

function createBaseAppLedgerEndorserSignatureSectionSchema(): AppLedgerEndorserSignatureSectionSchema {
  return { signature: new Uint8Array(0) };
}

export const AppLedgerEndorserSignatureSectionSchema: MessageFns<AppLedgerEndorserSignatureSectionSchema> = {
  encode(message: AppLedgerEndorserSignatureSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerEndorserSignatureSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerEndorserSignatureSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerEndorserSignatureSectionSchema {
    return { signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0) };
  },

  toJSON(message: AppLedgerEndorserSignatureSectionSchema): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerEndorserSignatureSectionSchema>, I>>(
    base?: I,
  ): AppLedgerEndorserSignatureSectionSchema {
    return AppLedgerEndorserSignatureSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerEndorserSignatureSectionSchema>, I>>(
    object: I,
  ): AppLedgerEndorserSignatureSectionSchema {
    const message = createBaseAppLedgerEndorserSignatureSectionSchema();
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAppLedgerAuthorSignatureSectionSchema(): AppLedgerAuthorSignatureSectionSchema {
  return { signature: new Uint8Array(0) };
}

export const AppLedgerAuthorSignatureSectionSchema: MessageFns<AppLedgerAuthorSignatureSectionSchema> = {
  encode(message: AppLedgerAuthorSignatureSectionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppLedgerAuthorSignatureSectionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppLedgerAuthorSignatureSectionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppLedgerAuthorSignatureSectionSchema {
    return { signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0) };
  },

  toJSON(message: AppLedgerAuthorSignatureSectionSchema): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AppLedgerAuthorSignatureSectionSchema>, I>>(
    base?: I,
  ): AppLedgerAuthorSignatureSectionSchema {
    return AppLedgerAuthorSignatureSectionSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AppLedgerAuthorSignatureSectionSchema>, I>>(
    object: I,
  ): AppLedgerAuthorSignatureSectionSchema {
    const message = createBaseAppLedgerAuthorSignatureSectionSchema();
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
