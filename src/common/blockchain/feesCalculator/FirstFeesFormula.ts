import {IFeesFormula} from "./IFeesFormula";
import {Microblock} from "../microblock/Microblock";
import {CMTSToken} from "../../economics/currencies/token";
import {ECO} from "../../constants/constants";
import {SectionType} from "../../type/valibot/blockchain/section/SectionType";
import {SignatureSchemeId} from "../../crypto/signature/SignatureSchemeId";
import {Section} from "../../type/valibot/blockchain/section/sections";
import {BlockchainUtils} from "../../utils/BlockchainUtils";

/**
 * FirstFeesFormula is a concrete implementation of the IFeesFormula interface.
 * It provides a mechanism to compute the fees for a transaction based on
 * the size of a given microblock and a fixed gas fee formula.
 */
export class FirstFeesFormula implements IFeesFormula {
    private static DEFAULT_GAS_PRICE = CMTSToken.createAtomic(1);

    async computeFees(signatureSchemeId: SignatureSchemeId, microblock: Microblock): Promise<CMTSToken> {
        const totalSize = this.computeSizeInBytesOfMicroblock(microblock);
        const definedGasPrice = microblock.getGasPrice();
        const usedGasPrice = definedGasPrice.isZero() ? FirstFeesFormula.DEFAULT_GAS_PRICE : definedGasPrice;
        const additionalCosts =  this.getAdditionalCosts(signatureSchemeId)
        const feesInAtomic =  (
            ECO.FIXED_GAS_FEE +
            ECO.GAS_PER_BYTE * totalSize +
            additionalCosts
        ) * usedGasPrice.getAmountAsAtomic();
        return CMTSToken.createAtomic(feesInAtomic);
    }

    private getAdditionalCosts(signatureSchemeId: SignatureSchemeId) {
        switch (signatureSchemeId) {
            case SignatureSchemeId.SECP256K1: {
                return 1000;
            }
            case SignatureSchemeId.ML_DSA_65: {
                return 5000;
            }
            case SignatureSchemeId.PKMS_SECP256K1: {
                return 0;
            }
        }
        return 0;
    }

    /**
     * Computes the total size in bytes of the provided microblock, excluding the last section
     * if it is a SIGNATURE type section.
     *
     * @param {Microblock} microblock - The microblock object whose size needs to be computed.
     * @return {number} The total size in bytes of the microblock, excluding any SIGNATURE type section at the end.
     */
    private computeSizeInBytesOfMicroblock(microblock: Microblock): number {
        const sections = microblock.getAllSections();
        if (sections.length === 0) return 0;

        // if the gas fees are set (non-zero) in the microblock then, with high probabilities, the microblock
        // will not be modified later one and so we exclude the last signature section.
        // otherwise, the microblock will be modified later one and so we include the last signature section.
        const gasFeesContainedInMicroblock = microblock.getGas();
        if (gasFeesContainedInMicroblock.isZero()) {
            let totalSize = this.getSizeOfListOfSections(sections);
            return totalSize
        } else {
            // if the last section is a signature, we exclude it from the computation of the total size
            const isLastSectionSig = sections[sections.length - 1].type === SectionType.SIGNATURE;
            let sectionsUsedInComputeOfSize = isLastSectionSig ?
                sections.slice(0, sections.length - 1) :
                sections;
            const totalSize = this.getSizeOfListOfSections(sectionsUsedInComputeOfSize)
            return totalSize
        }


    }

    private getSizeOfListOfSections(sections: Section[]): number {
        return sections.reduce(
            (total: number, section: Section) => {
                const serializedSection = BlockchainUtils.encodeSection(section)
                return total + serializedSection.length
            },
            0
        );
    }
}